// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncGenerator, __await } from "tslib";
import { createAnalyzeActionsResult } from "../../analyzeActionsResult";
import { getOperationId, handleInvalidDocumentBatch, nextLinkToTopAndSkip } from "../../util";
import { AnalysisPollOperation } from "../poller";
import { SpanStatusCode } from "@azure/core-tracing";
import { createSpan } from "../../tracing";
import { logger } from "../../logger";
/**
 * @internal
 */
function getMetaInfoFromResponse(response) {
    return {
        createdOn: response.createdDateTime,
        lastModifiedOn: response.lastUpdateDateTime,
        expiresOn: response.expirationDateTime,
        status: response.status,
        actionsSucceededCount: response.tasks.completed,
        actionsFailedCount: response.tasks.failed,
        actionsInProgressCount: response.tasks.inProgress,
        displayName: response.displayName
    };
}
/**
 * Class that represents a poller that waits for results of the analyze
 * operation.
 * @internal
 */
export class BeginAnalyzeActionsPollerOperation extends AnalysisPollOperation {
    constructor(state, 
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    client, documents, actions, options = {}) {
        super(state);
        this.state = state;
        this.client = client;
        this.documents = documents;
        this.actions = actions;
        this.options = options;
    }
    /**
     * should be called only after all the status of the analyze actions operations became
     * "succeeded" and it returns an iterator for the results and provides a
     * byPage method to return the results paged.
     */
    listAnalyzeActionsResults(operationId, options = {}) {
        const iter = this._listAnalyzeActionsResultsPaged(operationId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                const pageOptions = Object.assign(Object.assign({}, options), { top: settings === null || settings === void 0 ? void 0 : settings.maxPageSize });
                return this._listAnalyzeActionsResultsPaged(operationId, pageOptions);
            }
        };
    }
    /**
     * returns an iterator to arrays of the results of an analyze actions operation.
     */
    _listAnalyzeActionsResultsPaged(operationId, options) {
        return __asyncGenerator(this, arguments, function* _listAnalyzeActionsResultsPaged_1() {
            let response = yield __await(this._listAnalyzeActionsResultsSinglePage(operationId, options));
            yield yield __await(response.result);
            while (response.skip) {
                const optionsWithContinuation = Object.assign(Object.assign({}, options), { top: response.top, skip: response.skip });
                response = yield __await(this._listAnalyzeActionsResultsSinglePage(operationId, optionsWithContinuation));
                yield yield __await(response.result);
            }
        });
    }
    /**
     * returns an iterator to arrays of the sorted results of an analyze actions operation.
     */
    async _listAnalyzeActionsResultsSinglePage(operationId, options) {
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-_listAnalyzeActionsResultsSinglePage", options || {});
        try {
            const response = await this.client.analyzeStatus(operationId, finalOptions);
            const result = createAnalyzeActionsResult(response, this.documents);
            return response.nextLink
                ? Object.assign({ result }, nextLinkToTopAndSkip(response.nextLink)) : { result };
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * returns whether the analyze actions operation is done and if so returns also
     * statistics.
     */
    async getAnalyzeActionsOperationStatus(operationId, options) {
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-getAnalyzeActionsOperationStatus", options || {});
        try {
            const response = await this.client.analyzeStatus(operationId, finalOptions);
            switch (response.status) {
                case "notStarted":
                case "running":
                    break;
                default: {
                    return {
                        done: true,
                        statistics: response.statistics,
                        operationMetdata: getMetaInfoFromResponse(response)
                    };
                }
            }
            return { done: false, operationMetdata: getMetaInfoFromResponse(response) };
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async beginAnalyzeActions(documents, actions, options) {
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-beginAnalyze", options || {});
        try {
            return await this.client.analyze(Object.assign({ body: {
                    analysisInput: { documents: documents },
                    tasks: actions,
                    displayName: options === null || options === void 0 ? void 0 : options.displayName
                } }, finalOptions));
        }
        catch (e) {
            const exception = handleInvalidDocumentBatch(e);
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: exception.message
            });
            throw exception;
        }
        finally {
            span.end();
        }
    }
    async update(options = {}) {
        var _a;
        const state = this.state;
        const updatedAbortSignal = options.abortSignal;
        if (!state.isStarted) {
            state.isStarted = true;
            const response = await this.beginAnalyzeActions(this.documents, this.actions, {
                displayName: this.options.displayName,
                tracingOptions: this.options.tracingOptions,
                requestOptions: this.options.requestOptions,
                abortSignal: updatedAbortSignal ? updatedAbortSignal : this.options.abortSignal
            });
            if (!response.operationLocation) {
                throw new Error("Expects a valid 'operationLocation' to retrieve analyze results but did not find any");
            }
            state.operationId = getOperationId(response.operationLocation);
        }
        const operationStatus = await this.getAnalyzeActionsOperationStatus(state.operationId, {
            abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal,
            includeStatistics: this.options.includeStatistics,
            tracingOptions: this.options.tracingOptions
        });
        state.createdOn = operationStatus.operationMetdata.createdOn;
        state.expiresOn = operationStatus.operationMetdata.expiresOn;
        state.lastModifiedOn = operationStatus.operationMetdata.lastModifiedOn;
        state.status = operationStatus.operationMetdata.status;
        state.actionsSucceededCount = operationStatus.operationMetdata.actionsSucceededCount;
        state.actionsFailedCount = operationStatus.operationMetdata.actionsFailedCount;
        state.actionsInProgressCount = operationStatus.operationMetdata.actionsInProgressCount;
        state.displayName = (_a = operationStatus.operationMetdata) === null || _a === void 0 ? void 0 : _a.displayName;
        if (!state.isCompleted && operationStatus.done) {
            const pagedIterator = this.listAnalyzeActionsResults(state.operationId, {
                abortSignal: this.options.abortSignal,
                tracingOptions: this.options.tracingOptions,
                includeStatistics: this.options.includeStatistics,
                onResponse: this.options.onResponse,
                serializerOptions: this.options.serializerOptions
            });
            // Attach stats if the service starts to return them
            // https://github.com/Azure/azure-sdk-for-js/issues/14139
            // state.result = Object.assign(pagedIterator, {
            //   statistics: operationStatus.statistics
            // });
            state.result = pagedIterator;
            state.isCompleted = true;
        }
        if (typeof options.fireProgress === "function") {
            options.fireProgress(state);
        }
        return this;
    }
    async cancel() {
        const state = this.state;
        logger.warning(`The service does not yet support cancellation for beginAnalyze.`);
        state.isCancelled = true;
        return this;
    }
}
//# sourceMappingURL=operation.js.map