// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { makeAnalyzeSentimentResultArray } from "./analyzeSentimentResultArray";
import { makeExtractKeyPhrasesResultArray } from "./extractKeyPhrasesResultArray";
import { makeRecognizeCategorizedEntitiesResultArray } from "./recognizeCategorizedEntitiesResultArray";
import { makeRecognizeLinkedEntitiesResultArray } from "./recognizeLinkedEntitiesResultArray";
import { makeRecognizePiiEntitiesResultArray } from "./recognizePiiEntitiesResultArray";
import { intoTextAnalyticsError } from "./textAnalyticsResult";
/**
 * Converts the service task name (in the JSON pointer in an action error) to an action type name.
 * @param serviceActionType - The task type name the service uses.
 * @returns the action type name that the package uses
 * @internal
 */
function convertTaskTypeToActionType(taskType) {
    switch (taskType) {
        case "entityRecognitionTasks": {
            return "RecognizeCategorizedEntities";
        }
        case "entityRecognitionPiiTasks": {
            return "RecognizePiiEntities";
        }
        case "keyPhraseExtractionTasks": {
            return "ExtractKeyPhrases";
        }
        case "entityLinkingTasks": {
            return "RecognizeLinkedEntities";
        }
        case "sentimentAnalysisTasks": {
            return "AnalyzeSentiment";
        }
        default: {
            throw new Error(`unexpected action type from the service: ${taskType}`);
        }
    }
}
/**
 * Converts a service action error to one with the JSON pointer converted to an action index.
 * @param erredActions - the action error the service sent
 * @returns an action error with an action type and index
 * @internal
 */
export function parseActionError(erredActions) {
    if (erredActions.target) {
        const regex = new RegExp(/#\/tasks\/(entityRecognitionTasks|entityRecognitionPiiTasks|keyPhraseExtractionTasks|entityLinkingTasks|sentimentAnalysisTasks)\/(\d+)/);
        const result = regex.exec(erredActions.target);
        if (result !== null) {
            return {
                code: erredActions.code,
                message: erredActions.message,
                index: parseInt(result[2]),
                type: convertTaskTypeToActionType(result[1])
            };
        }
        else {
            throw new Error(`Pointer "${erredActions.target}" is not a valid action pointer`);
        }
    }
    else {
        throw new Error("expected an error with a target field referencing an action but did not get one");
    }
}
/**
 * Categorize each action error into a bucket according to its action type.
 * @param erredActions - list of action errors
 * @param recognizeEntitiesActionErrors - a list of recognize entities action errors to be filled from the errors list
 * @param recognizePiiEntitiesActionErrors - a list of recognize pii entities action errors to be filled from the errors list
 * @param extractKeyPhrasesActionErrors - a list of extract key phrases action errors to be filled from the errors list
 * @internal
 */
function categorizeActionErrors(erredActions, recognizeEntitiesActionErrors, recognizePiiEntitiesActionErrors, extractKeyPhrasesActionErrors, recognizeLinkedEntitiesActionErrors, analyzeSentimentActionErrors) {
    for (const error of erredActions) {
        const actionError = parseActionError(error);
        switch (actionError.type) {
            case "RecognizeCategorizedEntities": {
                recognizeEntitiesActionErrors.push(actionError);
                break;
            }
            case "RecognizePiiEntities": {
                recognizePiiEntitiesActionErrors.push(actionError);
                break;
            }
            case "ExtractKeyPhrases": {
                extractKeyPhrasesActionErrors.push(actionError);
                break;
            }
            case "RecognizeLinkedEntities": {
                recognizeLinkedEntitiesActionErrors.push(actionError);
                break;
            }
            case "AnalyzeSentiment": {
                analyzeSentimentActionErrors.push(actionError);
                break;
            }
        }
    }
}
/**
 * @internal
 * @param error - the error the service sent for a task
 * @param lastUpdateDateTime - the time when this task failed
 */
function createErredAction(error, lastUpdateDateTime) {
    return { error: intoTextAnalyticsError(error), failedOn: lastUpdateDateTime };
}
/**
 * Creates a list of results for any action.
 * @param documents - list of input documents
 * @param makeResultsArray - a function to convert the results of a service response to the SDK's one
 * @param succeededTasks - list of succeeded action results
 * @param erredActions - list of erred actions
 * @internal
 */
function makeActionResult(documents, makeResultsArray, succeededTasks, erredActions) {
    let errorIndex = 0;
    function convertTasksToActions(actions, task) {
        const { results: actionResults, lastUpdateDateTime } = task;
        if (actionResults !== undefined) {
            const recognizeEntitiesResults = makeResultsArray(documents, actionResults);
            return [
                ...actions,
                {
                    results: recognizeEntitiesResults,
                    completedOn: lastUpdateDateTime
                }
            ];
        }
        else {
            return [...actions, createErredAction(erredActions[errorIndex++], lastUpdateDateTime)];
        }
    }
    return succeededTasks.reduce(convertTasksToActions, []);
}
/**
 * Creates the user-friendly action results object for the begin analyze actions operation.
 * @param response - the begin analyze actions operation response
 * @param documents - the list of input documents
 * @returns - the user-friendly action results object
 * @internal
 */
export function createAnalyzeActionsResult(response, documents) {
    var _a, _b, _c, _d, _e, _f;
    const recognizeEntitiesActionErrors = [];
    const recognizePiiEntitiesActionErrors = [];
    const extractKeyPhrasesActionErrors = [];
    const recognizeLinkedEntitiesActionErrors = [];
    const analyzeSentimentActionErrors = [];
    categorizeActionErrors((_a = response === null || response === void 0 ? void 0 : response.errors) !== null && _a !== void 0 ? _a : [], recognizeEntitiesActionErrors, recognizePiiEntitiesActionErrors, extractKeyPhrasesActionErrors, recognizeLinkedEntitiesActionErrors, analyzeSentimentActionErrors);
    return {
        recognizeEntitiesResults: makeActionResult(documents, makeRecognizeCategorizedEntitiesResultArray, (_b = response.tasks.entityRecognitionTasks) !== null && _b !== void 0 ? _b : [], recognizeEntitiesActionErrors),
        recognizePiiEntitiesResults: makeActionResult(documents, makeRecognizePiiEntitiesResultArray, (_c = response.tasks.entityRecognitionPiiTasks) !== null && _c !== void 0 ? _c : [], recognizePiiEntitiesActionErrors),
        extractKeyPhrasesResults: makeActionResult(documents, makeExtractKeyPhrasesResultArray, (_d = response.tasks.keyPhraseExtractionTasks) !== null && _d !== void 0 ? _d : [], extractKeyPhrasesActionErrors),
        recognizeLinkedEntitiesResults: makeActionResult(documents, makeRecognizeLinkedEntitiesResultArray, (_e = response.tasks.entityLinkingTasks) !== null && _e !== void 0 ? _e : [], recognizeLinkedEntitiesActionErrors),
        analyzeSentimentResults: makeActionResult(documents, makeAnalyzeSentimentResultArray, (_f = response.tasks.sentimentAnalysisTasks) !== null && _f !== void 0 ? _f : [], analyzeSentimentActionErrors)
    };
}
//# sourceMappingURL=analyzeActionsResult.js.map