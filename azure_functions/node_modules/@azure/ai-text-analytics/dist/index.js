'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('@azure/core-asynciterator-polyfill');
var coreAuth = require('@azure/core-auth');
var tslib = require('tslib');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreClient = require('@azure/core-client');
var logger$1 = require('@azure/logger');
var url = require('url');
var coreTracing = require('@azure/core-tracing');
var coreLro = require('@azure/core-lro');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * @internal
 */
const SDK_VERSION = "5.1.0";

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const JobDescriptor = {
    type: {
        name: "Composite",
        className: "JobDescriptor",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnalysisInput = {
    type: {
        name: "Composite",
        className: "AnalysisInput",
        modelProperties: {
            analysisInput: {
                serializedName: "analysisInput",
                type: {
                    name: "Composite",
                    className: "MultiLanguageBatchInput"
                }
            }
        }
    }
};
const MultiLanguageBatchInput = {
    type: {
        name: "Composite",
        className: "MultiLanguageBatchInput",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextDocumentInput"
                        }
                    }
                }
            }
        }
    }
};
const TextDocumentInput = {
    type: {
        name: "Composite",
        className: "TextDocumentInput",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            language: {
                serializedName: "language",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobManifest = {
    type: {
        name: "Composite",
        className: "JobManifest",
        modelProperties: {
            tasks: {
                serializedName: "tasks",
                type: {
                    name: "Composite",
                    className: "JobManifestTasks"
                }
            }
        }
    }
};
const JobManifestTasks = {
    type: {
        name: "Composite",
        className: "JobManifestTasks",
        modelProperties: {
            entityRecognitionTasks: {
                serializedName: "entityRecognitionTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EntitiesTask"
                        }
                    }
                }
            },
            entityRecognitionPiiTasks: {
                serializedName: "entityRecognitionPiiTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PiiTask"
                        }
                    }
                }
            },
            keyPhraseExtractionTasks: {
                serializedName: "keyPhraseExtractionTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyPhrasesTask"
                        }
                    }
                }
            },
            entityLinkingTasks: {
                serializedName: "entityLinkingTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EntityLinkingTask"
                        }
                    }
                }
            },
            sentimentAnalysisTasks: {
                serializedName: "sentimentAnalysisTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentimentAnalysisTask"
                        }
                    }
                }
            }
        }
    }
};
const EntitiesTask = {
    type: {
        name: "Composite",
        className: "EntitiesTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "EntitiesTaskParameters"
                }
            }
        }
    }
};
const EntitiesTaskParameters = {
    type: {
        name: "Composite",
        className: "EntitiesTaskParameters",
        modelProperties: {
            modelVersion: {
                defaultValue: "latest",
                serializedName: "model-version",
                type: {
                    name: "String"
                }
            },
            loggingOptOut: {
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            },
            stringIndexType: {
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PiiTask = {
    type: {
        name: "Composite",
        className: "PiiTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "PiiTaskParameters"
                }
            }
        }
    }
};
const PiiTaskParameters = {
    type: {
        name: "Composite",
        className: "PiiTaskParameters",
        modelProperties: {
            domain: {
                defaultValue: "none",
                serializedName: "domain",
                type: {
                    name: "String"
                }
            },
            modelVersion: {
                defaultValue: "latest",
                serializedName: "model-version",
                type: {
                    name: "String"
                }
            },
            loggingOptOut: {
                defaultValue: true,
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            },
            piiCategories: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "piiCategories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            stringIndexType: {
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyPhrasesTask = {
    type: {
        name: "Composite",
        className: "KeyPhrasesTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "KeyPhrasesTaskParameters"
                }
            }
        }
    }
};
const KeyPhrasesTaskParameters = {
    type: {
        name: "Composite",
        className: "KeyPhrasesTaskParameters",
        modelProperties: {
            modelVersion: {
                defaultValue: "latest",
                serializedName: "model-version",
                type: {
                    name: "String"
                }
            },
            loggingOptOut: {
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const EntityLinkingTask = {
    type: {
        name: "Composite",
        className: "EntityLinkingTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "EntityLinkingTaskParameters"
                }
            }
        }
    }
};
const EntityLinkingTaskParameters = {
    type: {
        name: "Composite",
        className: "EntityLinkingTaskParameters",
        modelProperties: {
            modelVersion: {
                defaultValue: "latest",
                serializedName: "model-version",
                type: {
                    name: "String"
                }
            },
            loggingOptOut: {
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            },
            stringIndexType: {
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SentimentAnalysisTask = {
    type: {
        name: "Composite",
        className: "SentimentAnalysisTask",
        modelProperties: {
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Composite",
                    className: "SentimentAnalysisTaskParameters"
                }
            }
        }
    }
};
const SentimentAnalysisTaskParameters = {
    type: {
        name: "Composite",
        className: "SentimentAnalysisTaskParameters",
        modelProperties: {
            modelVersion: {
                defaultValue: "latest",
                serializedName: "model-version",
                type: {
                    name: "String"
                }
            },
            loggingOptOut: {
                serializedName: "loggingOptOut",
                type: {
                    name: "Boolean"
                }
            },
            opinionMining: {
                serializedName: "opinionMining",
                type: {
                    name: "Boolean"
                }
            },
            stringIndexType: {
                serializedName: "stringIndexType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "TextAnalyticsError"
                }
            }
        }
    }
};
const TextAnalyticsError = {
    type: {
        name: "Composite",
        className: "TextAnalyticsError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsError"
                        }
                    }
                }
            }
        }
    }
};
const InnerError = {
    type: {
        name: "Composite",
        className: "InnerError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "InnerError"
                }
            }
        }
    }
};
const JobMetadata = {
    type: {
        name: "Composite",
        className: "JobMetadata",
        modelProperties: {
            createdDateTime: {
                serializedName: "createdDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            expirationDateTime: {
                serializedName: "expirationDateTime",
                type: {
                    name: "DateTime"
                }
            },
            jobId: {
                serializedName: "jobId",
                required: true,
                type: {
                    name: "Uuid"
                }
            },
            lastUpdateDateTime: {
                serializedName: "lastUpdateDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "notStarted",
                        "running",
                        "succeeded",
                        "failed",
                        "rejected",
                        "cancelled",
                        "cancelling"
                    ]
                }
            }
        }
    }
};
const AnalyzeJobDisplayName = {
    type: {
        name: "Composite",
        className: "AnalyzeJobDisplayName",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TasksState = {
    type: {
        name: "Composite",
        className: "TasksState",
        modelProperties: {
            tasks: {
                serializedName: "tasks",
                type: {
                    name: "Composite",
                    className: "TasksStateTasks"
                }
            }
        }
    }
};
const TasksStateTasks = {
    type: {
        name: "Composite",
        className: "TasksStateTasks",
        modelProperties: {
            completed: {
                serializedName: "completed",
                required: true,
                type: {
                    name: "Number"
                }
            },
            failed: {
                serializedName: "failed",
                required: true,
                type: {
                    name: "Number"
                }
            },
            inProgress: {
                serializedName: "inProgress",
                required: true,
                type: {
                    name: "Number"
                }
            },
            total: {
                serializedName: "total",
                required: true,
                type: {
                    name: "Number"
                }
            },
            entityRecognitionTasks: {
                serializedName: "entityRecognitionTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksEntityRecognitionTasksItem"
                        }
                    }
                }
            },
            entityRecognitionPiiTasks: {
                serializedName: "entityRecognitionPiiTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksEntityRecognitionPiiTasksItem"
                        }
                    }
                }
            },
            keyPhraseExtractionTasks: {
                serializedName: "keyPhraseExtractionTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksKeyPhraseExtractionTasksItem"
                        }
                    }
                }
            },
            entityLinkingTasks: {
                serializedName: "entityLinkingTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksEntityLinkingTasksItem"
                        }
                    }
                }
            },
            sentimentAnalysisTasks: {
                serializedName: "sentimentAnalysisTasks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TasksStateTasksSentimentAnalysisTasksItem"
                        }
                    }
                }
            }
        }
    }
};
const TaskState = {
    type: {
        name: "Composite",
        className: "TaskState",
        modelProperties: {
            lastUpdateDateTime: {
                serializedName: "lastUpdateDateTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "notStarted",
                        "running",
                        "succeeded",
                        "failed",
                        "rejected",
                        "cancelled",
                        "cancelling"
                    ]
                }
            }
        }
    }
};
const EntitiesTaskResult = {
    type: {
        name: "Composite",
        className: "EntitiesTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "EntitiesResult"
                }
            }
        }
    }
};
const EntitiesResult = {
    type: {
        name: "Composite",
        className: "EntitiesResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentEntities"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentEntities = {
    type: {
        name: "Composite",
        className: "DocumentEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Entity"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const Entity = {
    type: {
        name: "Composite",
        className: "Entity",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                required: true,
                type: {
                    name: "String"
                }
            },
            subCategory: {
                serializedName: "subcategory",
                type: {
                    name: "String"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TextAnalyticsWarning = {
    type: {
        name: "Composite",
        className: "TextAnalyticsWarning",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TextDocumentStatistics = {
    type: {
        name: "Composite",
        className: "TextDocumentStatistics",
        modelProperties: {
            characterCount: {
                serializedName: "charactersCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            transactionCount: {
                serializedName: "transactionsCount",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DocumentError = {
    type: {
        name: "Composite",
        className: "DocumentError",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "TextAnalyticsError"
                }
            }
        }
    }
};
const TextDocumentBatchStatistics = {
    type: {
        name: "Composite",
        className: "TextDocumentBatchStatistics",
        modelProperties: {
            documentCount: {
                serializedName: "documentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            validDocumentCount: {
                serializedName: "validDocumentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            erroneousDocumentCount: {
                serializedName: "erroneousDocumentsCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            transactionCount: {
                serializedName: "transactionsCount",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PiiTaskResult = {
    type: {
        name: "Composite",
        className: "PiiTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "PiiResult"
                }
            }
        }
    }
};
const PiiResult = {
    type: {
        name: "Composite",
        className: "PiiResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PiiDocumentEntities"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PiiDocumentEntities = {
    type: {
        name: "Composite",
        className: "PiiDocumentEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            redactedText: {
                serializedName: "redactedText",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Entity"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const KeyPhraseTaskResult = {
    type: {
        name: "Composite",
        className: "KeyPhraseTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "KeyPhraseResult"
                }
            }
        }
    }
};
const KeyPhraseResult = {
    type: {
        name: "Composite",
        className: "KeyPhraseResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentKeyPhrases"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentKeyPhrases = {
    type: {
        name: "Composite",
        className: "DocumentKeyPhrases",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyPhrases: {
                serializedName: "keyPhrases",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const EntityLinkingTaskResult = {
    type: {
        name: "Composite",
        className: "EntityLinkingTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "EntityLinkingResult"
                }
            }
        }
    }
};
const EntityLinkingResult = {
    type: {
        name: "Composite",
        className: "EntityLinkingResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentLinkedEntities"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentLinkedEntities = {
    type: {
        name: "Composite",
        className: "DocumentLinkedEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LinkedEntity"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const LinkedEntity = {
    type: {
        name: "Composite",
        className: "LinkedEntity",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            matches: {
                serializedName: "matches",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Match"
                        }
                    }
                }
            },
            language: {
                serializedName: "language",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataSourceEntityId: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataSource: {
                serializedName: "dataSource",
                required: true,
                type: {
                    name: "String"
                }
            },
            bingEntitySearchApiId: {
                serializedName: "bingId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Match = {
    type: {
        name: "Composite",
        className: "Match",
        modelProperties: {
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SentimentTaskResult = {
    type: {
        name: "Composite",
        className: "SentimentTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "SentimentResponse"
                }
            }
        }
    }
};
const SentimentResponse = {
    type: {
        name: "Composite",
        className: "SentimentResponse",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentSentiment"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentSentiment = {
    type: {
        name: "Composite",
        className: "DocumentSentiment",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "neutral", "negative", "mixed"]
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "SentimentConfidenceScores"
                }
            },
            sentenceSentiments: {
                serializedName: "sentences",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentenceSentiment"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            }
        }
    }
};
const SentimentConfidenceScores = {
    type: {
        name: "Composite",
        className: "SentimentConfidenceScores",
        modelProperties: {
            positive: {
                serializedName: "positive",
                required: true,
                type: {
                    name: "Number"
                }
            },
            neutral: {
                serializedName: "neutral",
                required: true,
                type: {
                    name: "Number"
                }
            },
            negative: {
                serializedName: "negative",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SentenceSentiment = {
    type: {
        name: "Composite",
        className: "SentenceSentiment",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "neutral", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "SentimentConfidenceScores"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            targets: {
                serializedName: "targets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentenceTarget"
                        }
                    }
                }
            },
            assessments: {
                serializedName: "assessments",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SentenceAssessment"
                        }
                    }
                }
            }
        }
    }
};
const SentenceTarget = {
    type: {
        name: "Composite",
        className: "SentenceTarget",
        modelProperties: {
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "mixed", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "TargetConfidenceScoreLabel"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            relations: {
                serializedName: "relations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TargetRelation"
                        }
                    }
                }
            }
        }
    }
};
const TargetConfidenceScoreLabel = {
    type: {
        name: "Composite",
        className: "TargetConfidenceScoreLabel",
        modelProperties: {
            positive: {
                serializedName: "positive",
                required: true,
                type: {
                    name: "Number"
                }
            },
            negative: {
                serializedName: "negative",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TargetRelation = {
    type: {
        name: "Composite",
        className: "TargetRelation",
        modelProperties: {
            relationType: {
                serializedName: "relationType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["assessment", "target"]
                }
            },
            ref: {
                serializedName: "ref",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SentenceAssessment = {
    type: {
        name: "Composite",
        className: "SentenceAssessment",
        modelProperties: {
            sentiment: {
                serializedName: "sentiment",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["positive", "mixed", "negative"]
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Composite",
                    className: "TargetConfidenceScoreLabel"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            isNegated: {
                serializedName: "isNegated",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AnalyzeJobErrorsAndStatistics = {
    type: {
        name: "Composite",
        className: "AnalyzeJobErrorsAndStatistics",
        modelProperties: {
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            }
        }
    }
};
const Pagination = {
    type: {
        name: "Composite",
        className: "Pagination",
        modelProperties: {
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HealthcareTaskResult = {
    type: {
        name: "Composite",
        className: "HealthcareTaskResult",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Composite",
                    className: "HealthcareResult"
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsError"
                        }
                    }
                }
            }
        }
    }
};
const HealthcareResult = {
    type: {
        name: "Composite",
        className: "HealthcareResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentHealthcareEntities"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentHealthcareEntities = {
    type: {
        name: "Composite",
        className: "DocumentHealthcareEntities",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareEntity"
                        }
                    }
                }
            },
            relations: {
                serializedName: "relations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareRelation"
                        }
                    }
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const HealthcareEntityProperties = {
    type: {
        name: "Composite",
        className: "HealthcareEntityProperties",
        modelProperties: {
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                required: true,
                type: {
                    name: "String"
                }
            },
            subcategory: {
                serializedName: "subcategory",
                type: {
                    name: "String"
                }
            },
            offset: {
                serializedName: "offset",
                required: true,
                type: {
                    name: "Number"
                }
            },
            length: {
                serializedName: "length",
                required: true,
                type: {
                    name: "Number"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const HealthcareLinkingProperties = {
    type: {
        name: "Composite",
        className: "HealthcareLinkingProperties",
        modelProperties: {
            assertion: {
                serializedName: "assertion",
                type: {
                    name: "Composite",
                    className: "HealthcareAssertion"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            links: {
                serializedName: "links",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareEntityLink"
                        }
                    }
                }
            }
        }
    }
};
const HealthcareAssertion = {
    type: {
        name: "Composite",
        className: "HealthcareAssertion",
        modelProperties: {
            conditionality: {
                serializedName: "conditionality",
                type: {
                    name: "Enum",
                    allowedValues: ["hypothetical", "conditional"]
                }
            },
            certainty: {
                serializedName: "certainty",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "positive",
                        "positivePossible",
                        "neutralPossible",
                        "negativePossible",
                        "negative"
                    ]
                }
            },
            association: {
                serializedName: "association",
                type: {
                    name: "Enum",
                    allowedValues: ["subject", "other"]
                }
            }
        }
    }
};
const HealthcareEntityLink = {
    type: {
        name: "Composite",
        className: "HealthcareEntityLink",
        modelProperties: {
            dataSource: {
                serializedName: "dataSource",
                required: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HealthcareRelation = {
    type: {
        name: "Composite",
        className: "HealthcareRelation",
        modelProperties: {
            relationType: {
                serializedName: "relationType",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HealthcareRelationEntity"
                        }
                    }
                }
            }
        }
    }
};
const HealthcareRelationEntity = {
    type: {
        name: "Composite",
        className: "HealthcareRelationEntity",
        modelProperties: {
            ref: {
                serializedName: "ref",
                required: true,
                type: {
                    name: "String"
                }
            },
            role: {
                serializedName: "role",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LanguageBatchInput = {
    type: {
        name: "Composite",
        className: "LanguageBatchInput",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DetectLanguageInput"
                        }
                    }
                }
            }
        }
    }
};
const DetectLanguageInput = {
    type: {
        name: "Composite",
        className: "DetectLanguageInput",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                required: true,
                type: {
                    name: "String"
                }
            },
            countryHint: {
                serializedName: "countryHint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LanguageResult = {
    type: {
        name: "Composite",
        className: "LanguageResult",
        modelProperties: {
            documents: {
                serializedName: "documents",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentLanguage"
                        }
                    }
                }
            },
            errors: {
                serializedName: "errors",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DocumentError"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentBatchStatistics"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DocumentLanguage = {
    type: {
        name: "Composite",
        className: "DocumentLanguage",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            detectedLanguage: {
                serializedName: "detectedLanguage",
                type: {
                    name: "Composite",
                    className: "DetectedLanguage"
                }
            },
            warnings: {
                serializedName: "warnings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TextAnalyticsWarning"
                        }
                    }
                }
            },
            statistics: {
                serializedName: "statistics",
                type: {
                    name: "Composite",
                    className: "TextDocumentStatistics"
                }
            }
        }
    }
};
const DetectedLanguage = {
    type: {
        name: "Composite",
        className: "DetectedLanguage",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            iso6391Name: {
                serializedName: "iso6391Name",
                required: true,
                type: {
                    name: "String"
                }
            },
            confidenceScore: {
                serializedName: "confidenceScore",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AnalyzeBatchInput = {
    type: {
        name: "Composite",
        className: "AnalyzeBatchInput",
        modelProperties: Object.assign(Object.assign(Object.assign({}, JobDescriptor.type.modelProperties), AnalysisInput.type.modelProperties), JobManifest.type.modelProperties)
    }
};
const AnalyzeJobMetadata = {
    type: {
        name: "Composite",
        className: "AnalyzeJobMetadata",
        modelProperties: Object.assign(Object.assign({}, JobMetadata.type.modelProperties), AnalyzeJobDisplayName.type.modelProperties)
    }
};
const HealthcareJobState = {
    type: {
        name: "Composite",
        className: "HealthcareJobState",
        modelProperties: Object.assign(Object.assign(Object.assign({}, JobMetadata.type.modelProperties), HealthcareTaskResult.type.modelProperties), Pagination.type.modelProperties)
    }
};
const AnalyzeJobState = {
    type: {
        name: "Composite",
        className: "AnalyzeJobState",
        modelProperties: Object.assign(Object.assign(Object.assign(Object.assign({}, AnalyzeJobMetadata.type.modelProperties), TasksState.type.modelProperties), AnalyzeJobErrorsAndStatistics.type.modelProperties), Pagination.type.modelProperties)
    }
};
const TasksStateTasksEntityRecognitionTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksEntityRecognitionTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), EntitiesTaskResult.type.modelProperties)
    }
};
const TasksStateTasksEntityRecognitionPiiTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksEntityRecognitionPiiTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), PiiTaskResult.type.modelProperties)
    }
};
const TasksStateTasksKeyPhraseExtractionTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksKeyPhraseExtractionTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), KeyPhraseTaskResult.type.modelProperties)
    }
};
const TasksStateTasksEntityLinkingTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksEntityLinkingTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), EntityLinkingTaskResult.type.modelProperties)
    }
};
const TasksStateTasksSentimentAnalysisTasksItem = {
    type: {
        name: "Composite",
        className: "TasksStateTasksSentimentAnalysisTasksItem",
        modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), SentimentTaskResult.type.modelProperties)
    }
};
const HealthcareEntity = {
    type: {
        name: "Composite",
        className: "HealthcareEntity",
        modelProperties: Object.assign(Object.assign({}, HealthcareEntityProperties.type.modelProperties), HealthcareLinkingProperties.type.modelProperties)
    }
};
const GeneratedClientAnalyzeHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientAnalyzeHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientCancelHealthJobHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientCancelHealthJobHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GeneratedClientHealthHeaders = {
    type: {
        name: "Composite",
        className: "GeneratedClientHealthHeaders",
        modelProperties: {
            operationLocation: {
                serializedName: "operation-location",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    JobDescriptor: JobDescriptor,
    AnalysisInput: AnalysisInput,
    MultiLanguageBatchInput: MultiLanguageBatchInput,
    TextDocumentInput: TextDocumentInput,
    JobManifest: JobManifest,
    JobManifestTasks: JobManifestTasks,
    EntitiesTask: EntitiesTask,
    EntitiesTaskParameters: EntitiesTaskParameters,
    PiiTask: PiiTask,
    PiiTaskParameters: PiiTaskParameters,
    KeyPhrasesTask: KeyPhrasesTask,
    KeyPhrasesTaskParameters: KeyPhrasesTaskParameters,
    EntityLinkingTask: EntityLinkingTask,
    EntityLinkingTaskParameters: EntityLinkingTaskParameters,
    SentimentAnalysisTask: SentimentAnalysisTask,
    SentimentAnalysisTaskParameters: SentimentAnalysisTaskParameters,
    ErrorResponse: ErrorResponse,
    TextAnalyticsError: TextAnalyticsError,
    InnerError: InnerError,
    JobMetadata: JobMetadata,
    AnalyzeJobDisplayName: AnalyzeJobDisplayName,
    TasksState: TasksState,
    TasksStateTasks: TasksStateTasks,
    TaskState: TaskState,
    EntitiesTaskResult: EntitiesTaskResult,
    EntitiesResult: EntitiesResult,
    DocumentEntities: DocumentEntities,
    Entity: Entity,
    TextAnalyticsWarning: TextAnalyticsWarning,
    TextDocumentStatistics: TextDocumentStatistics,
    DocumentError: DocumentError,
    TextDocumentBatchStatistics: TextDocumentBatchStatistics,
    PiiTaskResult: PiiTaskResult,
    PiiResult: PiiResult,
    PiiDocumentEntities: PiiDocumentEntities,
    KeyPhraseTaskResult: KeyPhraseTaskResult,
    KeyPhraseResult: KeyPhraseResult,
    DocumentKeyPhrases: DocumentKeyPhrases,
    EntityLinkingTaskResult: EntityLinkingTaskResult,
    EntityLinkingResult: EntityLinkingResult,
    DocumentLinkedEntities: DocumentLinkedEntities,
    LinkedEntity: LinkedEntity,
    Match: Match,
    SentimentTaskResult: SentimentTaskResult,
    SentimentResponse: SentimentResponse,
    DocumentSentiment: DocumentSentiment,
    SentimentConfidenceScores: SentimentConfidenceScores,
    SentenceSentiment: SentenceSentiment,
    SentenceTarget: SentenceTarget,
    TargetConfidenceScoreLabel: TargetConfidenceScoreLabel,
    TargetRelation: TargetRelation,
    SentenceAssessment: SentenceAssessment,
    AnalyzeJobErrorsAndStatistics: AnalyzeJobErrorsAndStatistics,
    Pagination: Pagination,
    HealthcareTaskResult: HealthcareTaskResult,
    HealthcareResult: HealthcareResult,
    DocumentHealthcareEntities: DocumentHealthcareEntities,
    HealthcareEntityProperties: HealthcareEntityProperties,
    HealthcareLinkingProperties: HealthcareLinkingProperties,
    HealthcareAssertion: HealthcareAssertion,
    HealthcareEntityLink: HealthcareEntityLink,
    HealthcareRelation: HealthcareRelation,
    HealthcareRelationEntity: HealthcareRelationEntity,
    LanguageBatchInput: LanguageBatchInput,
    DetectLanguageInput: DetectLanguageInput,
    LanguageResult: LanguageResult,
    DocumentLanguage: DocumentLanguage,
    DetectedLanguage: DetectedLanguage,
    AnalyzeBatchInput: AnalyzeBatchInput,
    AnalyzeJobMetadata: AnalyzeJobMetadata,
    HealthcareJobState: HealthcareJobState,
    AnalyzeJobState: AnalyzeJobState,
    TasksStateTasksEntityRecognitionTasksItem: TasksStateTasksEntityRecognitionTasksItem,
    TasksStateTasksEntityRecognitionPiiTasksItem: TasksStateTasksEntityRecognitionPiiTasksItem,
    TasksStateTasksKeyPhraseExtractionTasksItem: TasksStateTasksKeyPhraseExtractionTasksItem,
    TasksStateTasksEntityLinkingTasksItem: TasksStateTasksEntityLinkingTasksItem,
    TasksStateTasksSentimentAnalysisTasksItem: TasksStateTasksSentimentAnalysisTasksItem,
    HealthcareEntity: HealthcareEntity,
    GeneratedClientAnalyzeHeaders: GeneratedClientAnalyzeHeaders,
    GeneratedClientCancelHealthJobHeaders: GeneratedClientCancelHealthJobHeaders,
    GeneratedClientHealthHeaders: GeneratedClientHealthHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: ["options", "body"],
    mapper: AnalyzeBatchInput
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json, text/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "Endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "v3.1",
        isConstant: true,
        serializedName: "ApiVersion",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const jobId = {
    parameterPath: "jobId",
    mapper: {
        serializedName: "jobId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const includeStatistics = {
    parameterPath: ["options", "includeStatistics"],
    mapper: {
        serializedName: "showStats",
        type: {
            name: "Boolean"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        defaultValue: 20,
        constraints: {
            InclusiveMaximum: 50,
            InclusiveMinimum: 1
        },
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const skip = {
    parameterPath: ["options", "skip"],
    mapper: {
        constraints: {
            InclusiveMinimum: 0
        },
        serializedName: "$skip",
        type: {
            name: "Number"
        }
    }
};
const jobId1 = {
    parameterPath: "jobId",
    mapper: {
        serializedName: "jobId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const input = {
    parameterPath: "input",
    mapper: MultiLanguageBatchInput
};
const modelVersion = {
    parameterPath: ["options", "modelVersion"],
    mapper: {
        serializedName: "model-version",
        type: {
            name: "String"
        }
    }
};
const stringIndexType = {
    parameterPath: ["options", "stringIndexType"],
    mapper: {
        serializedName: "stringIndexType",
        type: {
            name: "String"
        }
    }
};
const loggingOptOut = {
    parameterPath: ["options", "loggingOptOut"],
    mapper: {
        serializedName: "loggingOptOut",
        type: {
            name: "Boolean"
        }
    }
};
const domain = {
    parameterPath: ["options", "domain"],
    mapper: {
        serializedName: "domain",
        type: {
            name: "String"
        }
    }
};
const piiCategories = {
    parameterPath: ["options", "piiCategories"],
    mapper: {
        constraints: {
            UniqueItems: true
        },
        serializedName: "piiCategories",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const input1 = {
    parameterPath: "input",
    mapper: LanguageBatchInput
};
const opinionMining = {
    parameterPath: ["options", "opinionMining"],
    mapper: {
        serializedName: "opinionMining",
        type: {
            name: "Boolean"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class GeneratedClientContext extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClientContext class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-ai-text-analytics/5.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "{Endpoint}/text/analytics/{ApiVersion}" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "v3.1";
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class GeneratedClient extends GeneratedClientContext {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        super(endpoint, options);
    }
    /**
     * Submit a collection of text documents for analysis. Specify one or more unique tasks to be executed.
     * @param options The options parameters.
     */
    analyze(options) {
        return this.sendOperationRequest({ options }, analyzeOperationSpec);
    }
    /**
     * Get the status of an analysis job.  A job may consist of one or more tasks.  Once all tasks are
     * completed, the job will transition to the completed state and results will be available for each
     * task.
     * @param jobId Job ID for Analyze
     * @param options The options parameters.
     */
    analyzeStatus(jobId, options) {
        return this.sendOperationRequest({ jobId, options }, analyzeStatusOperationSpec);
    }
    /**
     * Get details of the healthcare prediction job specified by the jobId.
     * @param jobId Job ID
     * @param options The options parameters.
     */
    healthStatus(jobId, options) {
        return this.sendOperationRequest({ jobId, options }, healthStatusOperationSpec);
    }
    /**
     * Cancel healthcare prediction job.
     * @param jobId Job ID
     * @param options The options parameters.
     */
    cancelHealthJob(jobId, options) {
        return this.sendOperationRequest({ jobId, options }, cancelHealthJobOperationSpec);
    }
    /**
     * Start a healthcare analysis job to recognize healthcare related entities (drugs, conditions,
     * symptoms, etc) and their relations.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    health(input, options) {
        return this.sendOperationRequest({ input, options }, healthOperationSpec);
    }
    /**
     * The API returns a list of general named entities in a given document. For the list of supported
     * entity types, check <a href="https://aka.ms/taner">Supported Entity Types in Text Analytics API</a>.
     * See the <a href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list
     * of enabled languages.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    entitiesRecognitionGeneral(input, options) {
        return this.sendOperationRequest({ input, options }, entitiesRecognitionGeneralOperationSpec);
    }
    /**
     * The API returns a list of entities with personal information (\"SSN\", \"Bank Account\" etc) in the
     * document. For the list of supported entity types, check <a href="https://aka.ms/tanerpii">Supported
     * Entity Types in Text Analytics API</a>. See the <a href="https://aka.ms/talangs">Supported languages
     * in Text Analytics API</a> for the list of enabled languages.
     *
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    entitiesRecognitionPii(input, options) {
        return this.sendOperationRequest({ input, options }, entitiesRecognitionPiiOperationSpec);
    }
    /**
     * The API returns a list of recognized entities with links to a well known knowledge base. See the <a
     * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
     * languages.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    entitiesLinking(input, options) {
        return this.sendOperationRequest({ input, options }, entitiesLinkingOperationSpec);
    }
    /**
     * The API returns a list of strings denoting the key phrases in the input text. See the <a
     * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
     * languages.
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    keyPhrases(input, options) {
        return this.sendOperationRequest({ input, options }, keyPhrasesOperationSpec);
    }
    /**
     * The API returns the detected language and a numeric score between 0 and 1. Scores close to 1
     * indicate 100% certainty that the identified language is true. See the <a
     * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
     * languages.
     * @param input Collection of documents to analyze for language endpoint.
     * @param options The options parameters.
     */
    languages(input, options) {
        return this.sendOperationRequest({ input, options }, languagesOperationSpec);
    }
    /**
     * The API returns a detailed sentiment analysis for the input text. The analysis is done in multiple
     * levels of granularity, start from the a document level, down to sentence and key terms (targets and
     * assessments).
     * @param input Collection of documents to analyze.
     * @param options The options parameters.
     */
    sentiment(input, options) {
        return this.sendOperationRequest({ input, options }, sentimentOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const analyzeOperationSpec = {
    path: "/analyze",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientAnalyzeHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body,
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const analyzeStatusOperationSpec = {
    path: "/analyze/jobs/{jobId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AnalyzeJobState
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        includeStatistics,
        top,
        skip
    ],
    urlParameters: [endpoint, apiVersion, jobId],
    headerParameters: [accept],
    serializer
};
const healthStatusOperationSpec = {
    path: "/entities/health/jobs/{jobId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HealthcareJobState
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        includeStatistics,
        top,
        skip
    ],
    urlParameters: [
        endpoint,
        apiVersion,
        jobId1
    ],
    headerParameters: [accept],
    serializer
};
const cancelHealthJobOperationSpec = {
    path: "/entities/health/jobs/{jobId}",
    httpMethod: "DELETE",
    responses: {
        202: {
            headersMapper: GeneratedClientCancelHealthJobHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        endpoint,
        apiVersion,
        jobId1
    ],
    headerParameters: [accept],
    serializer
};
const healthOperationSpec = {
    path: "/entities/health/jobs",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: GeneratedClientHealthHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        modelVersion,
        stringIndexType,
        loggingOptOut
    ],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const entitiesRecognitionGeneralOperationSpec = {
    path: "/entities/recognition/general",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EntitiesResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        includeStatistics,
        modelVersion,
        stringIndexType,
        loggingOptOut
    ],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const entitiesRecognitionPiiOperationSpec = {
    path: "/entities/recognition/pii",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PiiResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        includeStatistics,
        modelVersion,
        stringIndexType,
        loggingOptOut,
        domain,
        piiCategories
    ],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const entitiesLinkingOperationSpec = {
    path: "/entities/linking",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EntityLinkingResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        includeStatistics,
        modelVersion,
        stringIndexType,
        loggingOptOut
    ],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const keyPhrasesOperationSpec = {
    path: "/keyPhrases",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: KeyPhraseResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        includeStatistics,
        modelVersion,
        loggingOptOut
    ],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const languagesOperationSpec = {
    path: "/languages",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LanguageResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input1,
    queryParameters: [
        includeStatistics,
        modelVersion,
        loggingOptOut
    ],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const sentimentOperationSpec = {
    path: "/sentiment",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SentimentResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: input,
    queryParameters: [
        includeStatistics,
        modelVersion,
        stringIndexType,
        loggingOptOut,
        opinionMining
    ],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};

// Copyright (c) Microsoft Corporation.
/**
 * The `@azure/logger` configuration for this package.
 * @internal
 */
const logger = logger$1.createClientLogger("ai-text-analytics");

// Copyright (c) Microsoft Corporation.
/**
 * Given a sorted array of input objects (with a unique ID) and an unsorted array of results,
 * return a sorted array of results.
 *
 * @internal
 * @param sortedArray - An array of entries sorted by `id`
 * @param unsortedArray - An array of entries that contain `id` but are not sorted
 */
function sortResponseIdObjects(sortedArray, unsortedArray) {
    const unsortedMap = new Map();
    for (const item of unsortedArray) {
        unsortedMap.set(item.id, item);
    }
    if (unsortedArray.length !== sortedArray.length) {
        const ordinal = unsortedArray.length > sortedArray.length ? "more" : "fewer";
        logger.warning(`The service returned ${ordinal} responses than inputs. Some errors may be treated as fatal.`);
    }
    const result = [];
    for (const sortedItem of sortedArray) {
        const item = unsortedMap.get(sortedItem.id);
        if (item) {
            result.push(item);
        }
    }
    return result;
}
/**
 * @internal
 */
function parseAssessmentIndex(pointer) {
    const regex = new RegExp(/#\/documents\/(\d+)\/sentences\/(\d+)\/assessments\/(\d+)/);
    const res = regex.exec(pointer);
    if (res !== null) {
        const assessmentIndex = {
            document: parseInt(res[1]),
            sentence: parseInt(res[2]),
            assessment: parseInt(res[3])
        };
        return assessmentIndex;
    }
    else {
        throw new Error(`Pointer "${pointer}" is not a valid Assessment pointer`);
    }
}
/**
 * Parses the index of the healthcare entity from a JSON pointer.
 * @param pointer - a JSON pointer representing an entity
 * @internal
 */
function parseHealthcareEntityIndex(pointer) {
    const regex = new RegExp(/#\/results\/documents\/(\d+)\/entities\/(\d+)/);
    const res = regex.exec(pointer);
    if (res !== null) {
        return parseInt(res[2]);
    }
    else {
        throw new Error(`Pointer "${pointer}" is not a valid healthcare entity pointer`);
    }
}
const jsEncodingUnit = "Utf16CodeUnit";
/**
 * @internal
 */
function addStrEncodingParam(options) {
    return Object.assign(Object.assign({}, options), { stringIndexType: options.stringIndexType || jsEncodingUnit });
}
/**
 * Set the stringIndexType property with default if it does not exist in x.
 * @param options - operation options bag that has a {@link StringIndexType}
 * @internal
 */
function setStrEncodingParam(x) {
    return Object.assign(Object.assign({}, x), { stringIndexType: x.stringIndexType || jsEncodingUnit });
}
function setStrEncodingParamValue(stringIndexType) {
    return stringIndexType || jsEncodingUnit;
}
/**
 * Set the opinion mining property
 * @internal
 */
function setOpinionMining(x) {
    return Object.assign(Object.assign({}, x), { opinionMining: x.includeOpinionMining });
}
/**
 * Set the pii categories property
 * @internal
 */
function setCategoriesFilter(x) {
    return Object.assign(Object.assign({}, x), { piiCategories: x.categoriesFilter });
}
/**
 * @internal
 */
function addParamsToTask(action) {
    const { actionName } = action, params = tslib.__rest(action, ["actionName"]);
    return { parameters: params, taskName: actionName };
}
/**
 * @internal
 */
function nextLinkToTopAndSkip(nextLink) {
    const url$1 = new url.URL(nextLink);
    const searchParams = new url.URLSearchParams(url$1.searchParams);
    let top;
    if (searchParams.has("$top")) {
        top = parseInt(searchParams.get("$top"));
    }
    else {
        throw new Error(`nextLink URL does not have the $top param: ${nextLink}`);
    }
    let skip;
    if (searchParams.has("$skip")) {
        skip = parseInt(searchParams.get("$skip"));
    }
    else {
        throw new Error(`nextLink URL does not have the $skip param: ${nextLink}`);
    }
    return {
        skip: skip,
        top: top
    };
}
/**
 * @internal
 */
function getOperationId(operationLocation) {
    const lastSlashIndex = operationLocation.lastIndexOf("/");
    return operationLocation.substring(lastSlashIndex + 1);
}
/**
 * @internal
 * parses incoming errors from the service and if the inner error code is
 * InvalidDocumentBatch, it exposes that as the statusCode instead.
 * @param error - the incoming error
 */
function handleInvalidDocumentBatch(error) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const castError = error;
    const innerCode = (_d = (_c = (_b = (_a = castError.response) === null || _a === void 0 ? void 0 : _a.parsedBody) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.innererror) === null || _d === void 0 ? void 0 : _d.code;
    const innerMessage = (_h = (_g = (_f = (_e = castError.response) === null || _e === void 0 ? void 0 : _e.parsedBody) === null || _f === void 0 ? void 0 : _f.error) === null || _g === void 0 ? void 0 : _g.innererror) === null || _h === void 0 ? void 0 : _h.message;
    if (innerMessage) {
        return innerCode === "InvalidDocumentBatch"
            ? new coreRestPipeline.RestError(innerMessage, { code: innerCode, statusCode: castError.statusCode })
            : error;
    }
    else {
        // unfortunately, the service currently does not follow the swagger definition
        // for errors in some cases.
        // Issue: https://msazure.visualstudio.com/Cognitive%20Services/_workitems/edit/8775003/?workitem=8972164
        // throw new Error(
        //   `The error coming from the service does not follow the expected structure: ${error}`
        // );
        logger.warning(`The error coming from the service does not follow the expected structure: ${error}`);
        return error;
    }
}
/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @internal
 * @param timeInMs - The number of milliseconds to be delayed.
 * @returns Resolved promise
 */
function delay(timeInMs) {
    return new Promise((resolve) => setTimeout(() => resolve(), timeInMs));
}
/**
 * @internal
 */
function compose(fn1, fn2) {
    return (value) => fn2(fn1(value));
}

// Copyright (c) Microsoft Corporation.
/**
 * Helper function for converting nested service error into
 * the unified TextAnalyticsError
 * @internal
 */
function intoTextAnalyticsError(errorModel) {
    // Return the deepest error. This will always be at most
    // one level for TextAnalytics
    if (errorModel.innererror !== undefined) {
        return intoTextAnalyticsError(errorModel.innererror);
    }
    return {
        code: errorModel.code,
        message: errorModel.message,
        target: errorModel.target
    };
}
/**
 * @internal
 */
function makeTextAnalyticsSuccessResult(id, warnings, statistics) {
    return {
        id,
        statistics,
        warnings
    };
}
/**
 * @internal
 */
function makeTextAnalyticsErrorResult(id, error) {
    return {
        id,
        error: intoTextAnalyticsError(error)
    };
}
/**
 * @internal
 * combines successful and erroneous results into a single array of results and
 * sort them so that the IDs order match that of the input documents array.
 * @param input - the array of documents sent to the service for processing.
 * @param response - the response received from the service.
 * @param process - a function to convert the results from one type to another.
 */
function processAndCombineSuccessfulAndErroneousDocuments(input, response, processSuccess, processError) {
    const successResults = response.documents.map(processSuccess);
    const unsortedResults = successResults.concat(response.errors.map((error) => processError(error.id, error.error)));
    return sortResponseIdObjects(input, unsortedResults);
}
/**
 * @internal
 * combines successful and erroneous results into a single array of results and
 * sort them so that the IDs order match that of the input documents array. It
 * also attaches statistics and modelVersion to the returned array.
 * @param input - the array of documents sent to the service for processing.
 * @param response - the response received from the service.
 */
function combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, processSuccess, processError) {
    const sorted = processAndCombineSuccessfulAndErroneousDocuments(input, response, processSuccess, processError);
    return Object.assign(sorted, {
        statistics: response.statistics,
        modelVersion: response.modelVersion
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeDetectLanguageResult(response) {
    const { id, warnings, statistics, detectedLanguage } = response;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { primaryLanguage: detectedLanguage });
}
/**
 * @internal
 */
function makeDetectLanguageErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeDetectLanguageResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, makeDetectLanguageResult, makeDetectLanguageErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeRecognizeCategorizedEntitiesResult(result) {
    const { entities, statistics, warnings, id } = result;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities });
}
/**
 * @internal
 */
function makeRecognizeCategorizedEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeRecognizeCategorizedEntitiesResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, makeRecognizeCategorizedEntitiesResult, makeRecognizeCategorizedEntitiesErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * @param document - A document result coming from the service.
 * @internal
 */
function makeAnalyzeSentimentResult(result) {
    const { id, sentiment, confidenceScores, sentenceSentiments: sentences, warnings, statistics } = result;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { sentiment,
        confidenceScores, sentences: sentences.map((sentence) => convertGeneratedSentenceSentiment(sentence, result)) });
}
/**
 * @internal
 */
function makeAnalyzeSentimentErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}
/**
 * Converts a sentence sentiment object returned by the service to another that
 * is user-friendly.
 *
 * @param sentence - The sentence sentiment object to be converted.
 * @param response - The entire response returned by the service.
 * @returns The user-friendly sentence sentiment object.
 * @internal
 */
function convertGeneratedSentenceSentiment(sentence, result) {
    return {
        confidenceScores: sentence.confidenceScores,
        sentiment: sentence.sentiment,
        text: sentence.text,
        offset: sentence.offset,
        length: sentence.length,
        opinions: sentence.targets
            ? sentence.targets.map((target) => ({
                target: {
                    confidenceScores: target.confidenceScores,
                    sentiment: target.sentiment,
                    text: target.text,
                    offset: target.offset,
                    length: target.length
                },
                assessments: target.relations
                    .filter((relation) => relation.relationType === "assessment")
                    .map((relation) => convertTargetRelationToAssessmentSentiment(relation, result))
            }))
            : []
    };
}
/**
 * Converts a target relation object returned by the service to an assessment
 * sentiment object where JSON pointers in the former are realized in the
 * latter.
 *
 * @param targetRelation - The target relation object to be converted.
 * @param response - The entire response returned by the service.
 * @returns The user-friendly assessment sentiment object.
 * @internal
 */
function convertTargetRelationToAssessmentSentiment(targetRelation, result) {
    var _a, _b;
    const assessmentPtr = targetRelation.ref;
    const assessmentIndex = parseAssessmentIndex(assessmentPtr);
    const assessment = (_b = (_a = result.sentenceSentiments) === null || _a === void 0 ? void 0 : _a[assessmentIndex.sentence].assessments) === null || _b === void 0 ? void 0 : _b[assessmentIndex.assessment];
    if (assessment !== undefined) {
        return assessment;
    }
    else {
        throw new Error(`Pointer "${assessmentPtr}" is not a valid Assessment pointer`);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeAnalyzeSentimentResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, makeAnalyzeSentimentResult, makeAnalyzeSentimentErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeExtractKeyPhrasesResult(result) {
    const { id, warnings, statistics, keyPhrases } = result;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { keyPhrases });
}
/**
 * @internal
 */
function makeExtractKeyPhrasesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeExtractKeyPhrasesResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, makeExtractKeyPhrasesResult, makeExtractKeyPhrasesErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeRecognizePiiEntitiesResult(document) {
    const { id, entities, warnings, statistics, redactedText } = document;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities,
        redactedText });
}
/**
 * @internal
 */
function makeRecognizePiiEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeRecognizePiiEntitiesResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, makeRecognizePiiEntitiesResult, makeRecognizePiiEntitiesErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeRecognizeLinkedEntitiesResult(result) {
    const { statistics, id, warnings, entities } = result;
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities });
}
/**
 * @internal
 */
function makeRecognizeLinkedEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function makeRecognizeLinkedEntitiesResultArray(input, response) {
    return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input, response, makeRecognizeLinkedEntitiesResult, makeRecognizeLinkedEntitiesErrorResult);
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @internal
 */
const createSpan = coreTracing.createSpanFunction({
    packagePrefix: "Azure.CognitiveServices.TextAnalytics",
    namespace: "Microsoft.CognitiveServices"
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const API_KEY_HEADER_NAME = "Ocp-Apim-Subscription-Key";
/**
 * The programmatic identifier of the textAnalyticsAzureKeyCredentialPolicy.
 */
const textAnalyticsAzureKeyCredentialPolicyName = "textAnalyticsAzureKeyCredentialPolicy";
/**
 * Create an HTTP pipeline policy to authenticate a request
 * using an `AzureKeyCredential` for Text Analytics
 * @internal
 */
function textAnalyticsAzureKeyCredentialPolicy(credential) {
    return {
        name: textAnalyticsAzureKeyCredentialPolicyName,
        sendRequest(request, next) {
            request.headers.set(API_KEY_HEADER_NAME, credential.key);
            return next(request);
        }
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Common properties and methods of analysis Pollers.
 * @internal
 */
class AnalysisPoller extends coreLro.Poller {
    constructor() {
        super(...arguments);
        /**
         * Defines how much time the poller is going to wait before making a new request to the service.
         */
        this.updateIntervalInMs = 2000;
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     */
    async delay() {
        return delay(this.updateIntervalInMs);
    }
}
/**
 * Common properties and methods of polling operations.
 * @internal
 */
class AnalysisPollOperation {
    constructor(state) {
        this.state = state;
    }
    /**
     * Serializes the Poller operation.
     */
    toString() {
        return JSON.stringify({
            state: this.state
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a user-friendly healthcare entity represented as a node in a graph
 * @param entity - the healthcare entity returned by the service
 * @internal
 */
function makeHealthcareEntitiesWithoutNeighbors(entity) {
    var _a;
    const { category, confidenceScore, assertion, offset, text, links, subcategory, length, name } = entity;
    return {
        category,
        confidenceScore,
        assertion,
        offset,
        length,
        text,
        normalizedText: name,
        subCategory: subcategory,
        dataSources: (_a = links === null || links === void 0 ? void 0 : links.map(({ dataSource, id }) => ({ name: dataSource, entityId: id }))) !== null && _a !== void 0 ? _a : []
    };
}
/**
 * @internal
 */
function makeHealthcareRelations(entities, relations) {
    return relations.map((relation) => ({
        relationType: relation.relationType,
        roles: relation.entities.map((role) => ({
            entity: entities[parseHealthcareEntityIndex(role.ref)],
            name: role.role
        }))
    }));
}
/**
 * Creates a healthcare entity in the convenience layer from the one sent by the service.
 * @param document - incoming results sent by the service for a particular document
 * @internal
 */
function makeHealthcareEntitiesResult(document) {
    const { id, entities, relations, warnings, statistics } = document;
    const newEntities = entities.map(makeHealthcareEntitiesWithoutNeighbors);
    return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities: newEntities, entityRelations: makeHealthcareRelations(newEntities, relations) });
}
/**
 * @internal
 */
function makeHealthcareEntitiesErrorResult(id, error) {
    return makeTextAnalyticsErrorResult(id, error);
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function getMetaInfoFromResponse(response) {
    return {
        createdOn: response.createdDateTime,
        lastModifiedOn: response.lastUpdateDateTime,
        expiresOn: response.expirationDateTime,
        status: response.status
    };
}
/**
 * Class that represents a poller that waits for the healthcare results.
 * @internal
 */
class BeginAnalyzeHealthcarePollerOperation extends AnalysisPollOperation {
    constructor(state, 
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    client, documents, options = {}) {
        super(state);
        this.state = state;
        this.client = client;
        this.documents = documents;
        this.options = options;
    }
    /**
     * should be called only after all the status of the healthcare operations became
     * "succeeded" and it returns an iterator for the results and provides a
     * byPage method to return the results paged.
     */
    listHealthcareEntitiesByPage(operationId, options = {}) {
        const iter = this._listHealthcareEntities(operationId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                const pageOptions = Object.assign(Object.assign({}, options), { top: settings === null || settings === void 0 ? void 0 : settings.maxPageSize });
                return this._listHealthcareEntitiesPaged(operationId, pageOptions);
            }
        };
    }
    /**
     * returns an iterator to the results of a healthcare operation.
     */
    _listHealthcareEntities(operationId, options) {
        return tslib.__asyncGenerator(this, arguments, function* _listHealthcareEntities_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this._listHealthcareEntitiesPaged(operationId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * returns an iterator to arrays of the results of a healthcare operation.
     */
    _listHealthcareEntitiesPaged(operationId, options) {
        return tslib.__asyncGenerator(this, arguments, function* _listHealthcareEntitiesPaged_1() {
            let response = yield tslib.__await(this._listHealthcareEntitiesSinglePage(operationId, options));
            yield yield tslib.__await(response.result);
            while (response.skip) {
                const optionsWithContinuation = Object.assign(Object.assign({}, options), { top: response.top, skip: response.skip });
                response = yield tslib.__await(this._listHealthcareEntitiesSinglePage(operationId, optionsWithContinuation));
                yield yield tslib.__await(response.result);
            }
        });
    }
    /**
     * returns an iterator to arrays of the sorted results of a healthcare operation.
     */
    async _listHealthcareEntitiesSinglePage(operationId, options) {
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-_listHealthcareEntitiesSinglePage", options || {});
        try {
            const response = await this.client.healthStatus(operationId, finalOptions);
            if (response.results) {
                const result = processAndCombineSuccessfulAndErroneousDocuments(this.documents, response.results, makeHealthcareEntitiesResult, makeHealthcareEntitiesErrorResult);
                return response.nextLink
                    ? Object.assign({ result }, nextLinkToTopAndSkip(response.nextLink)) : { result };
            }
            else {
                throw new Error("Healthcare action has succeeded but the there are no results!");
            }
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * returns whether the healthcare operation is done and if so returns also
     * statistics and the model version used.
     */
    async getHealthStatus(operationId, options) {
        var _a;
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-getHealthStatus", options || {});
        try {
            const response = await this.client.healthStatus(operationId, finalOptions);
            switch (response.status) {
                case "notStarted":
                case "running":
                    break;
                case "failed": {
                    const errors = (_a = response.errors) === null || _a === void 0 ? void 0 : _a.map((e) => `  code ${e.code}, message: '${e.message}'`).join("\n");
                    const message = `Healthcare analysis failed. Error(s): ${errors || ""}`;
                    throw new Error(message);
                }
                default: {
                    if (response.results) {
                        return {
                            done: true,
                            statistics: response.results.statistics,
                            modelVersion: response.results.modelVersion,
                            operationMetdata: getMetaInfoFromResponse(response)
                        };
                    }
                    else {
                        throw new Error("Healthcare action has finished but the there are no results!");
                    }
                }
            }
            return { done: false, operationMetdata: getMetaInfoFromResponse(response) };
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async beginAnalyzeHealthcare(documents, options) {
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-beginAnalyzeHealthcare", addStrEncodingParam(options || {}));
        try {
            return await this.client.health({ documents: documents }, finalOptions);
        }
        catch (e) {
            const exception = handleInvalidDocumentBatch(e);
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: exception.message
            });
            throw exception;
        }
        finally {
            span.end();
        }
    }
    async update(options = {}) {
        const state = this.state;
        const updatedAbortSignal = options.abortSignal;
        if (!state.isStarted) {
            state.isStarted = true;
            const response = await this.beginAnalyzeHealthcare(this.documents, {
                requestOptions: this.options.requestOptions,
                tracingOptions: this.options.tracingOptions,
                abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal,
                modelVersion: this.options.modelVersion,
                stringIndexType: this.options.stringIndexType,
                loggingOptOut: this.options.disableServiceLogs
            });
            if (!response.operationLocation) {
                throw new Error("Expects a valid 'operationLocation' to retrieve health results but did not find any");
            }
            state.operationId = getOperationId(response.operationLocation);
        }
        const operationStatus = await this.getHealthStatus(state.operationId, {
            abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal,
            includeStatistics: this.options.includeStatistics,
            tracingOptions: this.options.tracingOptions,
            onResponse: this.options.onResponse,
            serializerOptions: this.options.serializerOptions
        });
        state.createdOn = operationStatus.operationMetdata.createdOn;
        state.expiresOn = operationStatus.operationMetdata.expiresOn;
        state.lastModifiedOn = operationStatus.operationMetdata.lastModifiedOn;
        state.status = operationStatus.operationMetdata.status;
        if (!state.isCompleted && operationStatus.done) {
            const pagedIterator = this.listHealthcareEntitiesByPage(state.operationId, {
                abortSignal: this.options.abortSignal,
                tracingOptions: this.options.tracingOptions
            });
            state.result = Object.assign(pagedIterator, {
                statistics: operationStatus.statistics,
                modelVersion: operationStatus.modelVersion
            });
            state.isCompleted = true;
        }
        if (typeof options.fireProgress === "function") {
            options.fireProgress(state);
        }
        return this;
    }
    async cancel() {
        const state = this.state;
        if (state.operationId) {
            await this.client.cancelHealthJob(state.operationId, {
                abortSignal: this.options.abortSignal,
                tracingOptions: this.options.tracingOptions
            });
        }
        state.isCancelled = true;
        return this;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that represents a poller that waits for the healthcare results.
 * @internal
 */
class BeginAnalyzeHealthcarePoller extends AnalysisPoller {
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    constructor(inputs) {
        const { client, documents, options, updateIntervalInMs = 5000, resumeFrom } = inputs;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = new BeginAnalyzeHealthcarePollerOperation((state || {}), client, documents, options);
        super(operation);
        this.updateIntervalInMs = updateIntervalInMs;
    }
    delay() {
        return delay(this.updateIntervalInMs);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Converts the service task name (in the JSON pointer in an action error) to an action type name.
 * @param serviceActionType - The task type name the service uses.
 * @returns the action type name that the package uses
 * @internal
 */
function convertTaskTypeToActionType(taskType) {
    switch (taskType) {
        case "entityRecognitionTasks": {
            return "RecognizeCategorizedEntities";
        }
        case "entityRecognitionPiiTasks": {
            return "RecognizePiiEntities";
        }
        case "keyPhraseExtractionTasks": {
            return "ExtractKeyPhrases";
        }
        case "entityLinkingTasks": {
            return "RecognizeLinkedEntities";
        }
        case "sentimentAnalysisTasks": {
            return "AnalyzeSentiment";
        }
        default: {
            throw new Error(`unexpected action type from the service: ${taskType}`);
        }
    }
}
/**
 * Converts a service action error to one with the JSON pointer converted to an action index.
 * @param erredActions - the action error the service sent
 * @returns an action error with an action type and index
 * @internal
 */
function parseActionError(erredActions) {
    if (erredActions.target) {
        const regex = new RegExp(/#\/tasks\/(entityRecognitionTasks|entityRecognitionPiiTasks|keyPhraseExtractionTasks|entityLinkingTasks|sentimentAnalysisTasks)\/(\d+)/);
        const result = regex.exec(erredActions.target);
        if (result !== null) {
            return {
                code: erredActions.code,
                message: erredActions.message,
                index: parseInt(result[2]),
                type: convertTaskTypeToActionType(result[1])
            };
        }
        else {
            throw new Error(`Pointer "${erredActions.target}" is not a valid action pointer`);
        }
    }
    else {
        throw new Error("expected an error with a target field referencing an action but did not get one");
    }
}
/**
 * Categorize each action error into a bucket according to its action type.
 * @param erredActions - list of action errors
 * @param recognizeEntitiesActionErrors - a list of recognize entities action errors to be filled from the errors list
 * @param recognizePiiEntitiesActionErrors - a list of recognize pii entities action errors to be filled from the errors list
 * @param extractKeyPhrasesActionErrors - a list of extract key phrases action errors to be filled from the errors list
 * @internal
 */
function categorizeActionErrors(erredActions, recognizeEntitiesActionErrors, recognizePiiEntitiesActionErrors, extractKeyPhrasesActionErrors, recognizeLinkedEntitiesActionErrors, analyzeSentimentActionErrors) {
    for (const error of erredActions) {
        const actionError = parseActionError(error);
        switch (actionError.type) {
            case "RecognizeCategorizedEntities": {
                recognizeEntitiesActionErrors.push(actionError);
                break;
            }
            case "RecognizePiiEntities": {
                recognizePiiEntitiesActionErrors.push(actionError);
                break;
            }
            case "ExtractKeyPhrases": {
                extractKeyPhrasesActionErrors.push(actionError);
                break;
            }
            case "RecognizeLinkedEntities": {
                recognizeLinkedEntitiesActionErrors.push(actionError);
                break;
            }
            case "AnalyzeSentiment": {
                analyzeSentimentActionErrors.push(actionError);
                break;
            }
        }
    }
}
/**
 * @internal
 * @param error - the error the service sent for a task
 * @param lastUpdateDateTime - the time when this task failed
 */
function createErredAction(error, lastUpdateDateTime) {
    return { error: intoTextAnalyticsError(error), failedOn: lastUpdateDateTime };
}
/**
 * Creates a list of results for any action.
 * @param documents - list of input documents
 * @param makeResultsArray - a function to convert the results of a service response to the SDK's one
 * @param succeededTasks - list of succeeded action results
 * @param erredActions - list of erred actions
 * @internal
 */
function makeActionResult(documents, makeResultsArray, succeededTasks, erredActions) {
    let errorIndex = 0;
    function convertTasksToActions(actions, task) {
        const { results: actionResults, lastUpdateDateTime } = task;
        if (actionResults !== undefined) {
            const recognizeEntitiesResults = makeResultsArray(documents, actionResults);
            return [
                ...actions,
                {
                    results: recognizeEntitiesResults,
                    completedOn: lastUpdateDateTime
                }
            ];
        }
        else {
            return [...actions, createErredAction(erredActions[errorIndex++], lastUpdateDateTime)];
        }
    }
    return succeededTasks.reduce(convertTasksToActions, []);
}
/**
 * Creates the user-friendly action results object for the begin analyze actions operation.
 * @param response - the begin analyze actions operation response
 * @param documents - the list of input documents
 * @returns - the user-friendly action results object
 * @internal
 */
function createAnalyzeActionsResult(response, documents) {
    var _a, _b, _c, _d, _e, _f;
    const recognizeEntitiesActionErrors = [];
    const recognizePiiEntitiesActionErrors = [];
    const extractKeyPhrasesActionErrors = [];
    const recognizeLinkedEntitiesActionErrors = [];
    const analyzeSentimentActionErrors = [];
    categorizeActionErrors((_a = response === null || response === void 0 ? void 0 : response.errors) !== null && _a !== void 0 ? _a : [], recognizeEntitiesActionErrors, recognizePiiEntitiesActionErrors, extractKeyPhrasesActionErrors, recognizeLinkedEntitiesActionErrors, analyzeSentimentActionErrors);
    return {
        recognizeEntitiesResults: makeActionResult(documents, makeRecognizeCategorizedEntitiesResultArray, (_b = response.tasks.entityRecognitionTasks) !== null && _b !== void 0 ? _b : [], recognizeEntitiesActionErrors),
        recognizePiiEntitiesResults: makeActionResult(documents, makeRecognizePiiEntitiesResultArray, (_c = response.tasks.entityRecognitionPiiTasks) !== null && _c !== void 0 ? _c : [], recognizePiiEntitiesActionErrors),
        extractKeyPhrasesResults: makeActionResult(documents, makeExtractKeyPhrasesResultArray, (_d = response.tasks.keyPhraseExtractionTasks) !== null && _d !== void 0 ? _d : [], extractKeyPhrasesActionErrors),
        recognizeLinkedEntitiesResults: makeActionResult(documents, makeRecognizeLinkedEntitiesResultArray, (_e = response.tasks.entityLinkingTasks) !== null && _e !== void 0 ? _e : [], recognizeLinkedEntitiesActionErrors),
        analyzeSentimentResults: makeActionResult(documents, makeAnalyzeSentimentResultArray, (_f = response.tasks.sentimentAnalysisTasks) !== null && _f !== void 0 ? _f : [], analyzeSentimentActionErrors)
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function getMetaInfoFromResponse$1(response) {
    return {
        createdOn: response.createdDateTime,
        lastModifiedOn: response.lastUpdateDateTime,
        expiresOn: response.expirationDateTime,
        status: response.status,
        actionsSucceededCount: response.tasks.completed,
        actionsFailedCount: response.tasks.failed,
        actionsInProgressCount: response.tasks.inProgress,
        displayName: response.displayName
    };
}
/**
 * Class that represents a poller that waits for results of the analyze
 * operation.
 * @internal
 */
class BeginAnalyzeActionsPollerOperation extends AnalysisPollOperation {
    constructor(state, 
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    client, documents, actions, options = {}) {
        super(state);
        this.state = state;
        this.client = client;
        this.documents = documents;
        this.actions = actions;
        this.options = options;
    }
    /**
     * should be called only after all the status of the analyze actions operations became
     * "succeeded" and it returns an iterator for the results and provides a
     * byPage method to return the results paged.
     */
    listAnalyzeActionsResults(operationId, options = {}) {
        const iter = this._listAnalyzeActionsResultsPaged(operationId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                const pageOptions = Object.assign(Object.assign({}, options), { top: settings === null || settings === void 0 ? void 0 : settings.maxPageSize });
                return this._listAnalyzeActionsResultsPaged(operationId, pageOptions);
            }
        };
    }
    /**
     * returns an iterator to arrays of the results of an analyze actions operation.
     */
    _listAnalyzeActionsResultsPaged(operationId, options) {
        return tslib.__asyncGenerator(this, arguments, function* _listAnalyzeActionsResultsPaged_1() {
            let response = yield tslib.__await(this._listAnalyzeActionsResultsSinglePage(operationId, options));
            yield yield tslib.__await(response.result);
            while (response.skip) {
                const optionsWithContinuation = Object.assign(Object.assign({}, options), { top: response.top, skip: response.skip });
                response = yield tslib.__await(this._listAnalyzeActionsResultsSinglePage(operationId, optionsWithContinuation));
                yield yield tslib.__await(response.result);
            }
        });
    }
    /**
     * returns an iterator to arrays of the sorted results of an analyze actions operation.
     */
    async _listAnalyzeActionsResultsSinglePage(operationId, options) {
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-_listAnalyzeActionsResultsSinglePage", options || {});
        try {
            const response = await this.client.analyzeStatus(operationId, finalOptions);
            const result = createAnalyzeActionsResult(response, this.documents);
            return response.nextLink
                ? Object.assign({ result }, nextLinkToTopAndSkip(response.nextLink)) : { result };
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * returns whether the analyze actions operation is done and if so returns also
     * statistics.
     */
    async getAnalyzeActionsOperationStatus(operationId, options) {
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-getAnalyzeActionsOperationStatus", options || {});
        try {
            const response = await this.client.analyzeStatus(operationId, finalOptions);
            switch (response.status) {
                case "notStarted":
                case "running":
                    break;
                default: {
                    return {
                        done: true,
                        statistics: response.statistics,
                        operationMetdata: getMetaInfoFromResponse$1(response)
                    };
                }
            }
            return { done: false, operationMetdata: getMetaInfoFromResponse$1(response) };
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async beginAnalyzeActions(documents, actions, options) {
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-beginAnalyze", options || {});
        try {
            return await this.client.analyze(Object.assign({ body: {
                    analysisInput: { documents: documents },
                    tasks: actions,
                    displayName: options === null || options === void 0 ? void 0 : options.displayName
                } }, finalOptions));
        }
        catch (e) {
            const exception = handleInvalidDocumentBatch(e);
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: exception.message
            });
            throw exception;
        }
        finally {
            span.end();
        }
    }
    async update(options = {}) {
        var _a;
        const state = this.state;
        const updatedAbortSignal = options.abortSignal;
        if (!state.isStarted) {
            state.isStarted = true;
            const response = await this.beginAnalyzeActions(this.documents, this.actions, {
                displayName: this.options.displayName,
                tracingOptions: this.options.tracingOptions,
                requestOptions: this.options.requestOptions,
                abortSignal: updatedAbortSignal ? updatedAbortSignal : this.options.abortSignal
            });
            if (!response.operationLocation) {
                throw new Error("Expects a valid 'operationLocation' to retrieve analyze results but did not find any");
            }
            state.operationId = getOperationId(response.operationLocation);
        }
        const operationStatus = await this.getAnalyzeActionsOperationStatus(state.operationId, {
            abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal,
            includeStatistics: this.options.includeStatistics,
            tracingOptions: this.options.tracingOptions
        });
        state.createdOn = operationStatus.operationMetdata.createdOn;
        state.expiresOn = operationStatus.operationMetdata.expiresOn;
        state.lastModifiedOn = operationStatus.operationMetdata.lastModifiedOn;
        state.status = operationStatus.operationMetdata.status;
        state.actionsSucceededCount = operationStatus.operationMetdata.actionsSucceededCount;
        state.actionsFailedCount = operationStatus.operationMetdata.actionsFailedCount;
        state.actionsInProgressCount = operationStatus.operationMetdata.actionsInProgressCount;
        state.displayName = (_a = operationStatus.operationMetdata) === null || _a === void 0 ? void 0 : _a.displayName;
        if (!state.isCompleted && operationStatus.done) {
            const pagedIterator = this.listAnalyzeActionsResults(state.operationId, {
                abortSignal: this.options.abortSignal,
                tracingOptions: this.options.tracingOptions,
                includeStatistics: this.options.includeStatistics,
                onResponse: this.options.onResponse,
                serializerOptions: this.options.serializerOptions
            });
            // Attach stats if the service starts to return them
            // https://github.com/Azure/azure-sdk-for-js/issues/14139
            // state.result = Object.assign(pagedIterator, {
            //   statistics: operationStatus.statistics
            // });
            state.result = pagedIterator;
            state.isCompleted = true;
        }
        if (typeof options.fireProgress === "function") {
            options.fireProgress(state);
        }
        return this;
    }
    async cancel() {
        const state = this.state;
        logger.warning(`The service does not yet support cancellation for beginAnalyze.`);
        state.isCancelled = true;
        return this;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Class that represents a poller that waits for the analyze actions results.
 * @internal
 */
class BeginAnalyzeActionsPoller extends AnalysisPoller {
    // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
    constructor(pollerOptions) {
        const { client, documents, actions, options, updateIntervalInMs = 5000, resumeFrom } = pollerOptions;
        let state;
        if (resumeFrom) {
            state = JSON.parse(resumeFrom).state;
        }
        const operation = new BeginAnalyzeActionsPollerOperation((state || {}), client, documents, actions, options);
        super(operation);
        this.updateIntervalInMs = updateIntervalInMs;
    }
    delay() {
        return delay(this.updateIntervalInMs);
    }
}

// Copyright (c) Microsoft Corporation.
const DEFAULT_COGNITIVE_SCOPE = "https://cognitiveservices.azure.com/.default";
(function (PiiEntityDomain) {
    /**
     * @see {@link https://aka.ms/tanerpii} for more information.
     */
    PiiEntityDomain["PROTECTED_HEALTH_INFORMATION"] = "PHI";
})(exports.PiiEntityDomain || (exports.PiiEntityDomain = {}));
/**
 * Client class for interacting with Azure Text Analytics.
 */
class TextAnalyticsClient {
    /**
     * Creates an instance of TextAnalyticsClient.
     *
     * Example usage:
     * ```ts
     * import { TextAnalyticsClient, AzureKeyCredential } from "@azure/ai-text-analytics";
     *
     * const client = new TextAnalyticsClient(
     *    "<service endpoint>",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     * @param endpointUrl - The URL to the TextAnalytics endpoint
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the TextAnalytics client.
     */
    constructor(endpointUrl, credential, options = {}) {
        this.endpointUrl = endpointUrl;
        const { defaultCountryHint = "us", defaultLanguage = "en" } = options, pipelineOptions = tslib.__rest(options, ["defaultCountryHint", "defaultLanguage"]);
        this.defaultCountryHint = defaultCountryHint;
        this.defaultLanguage = defaultLanguage;
        const libInfo = `azsdk-js-ai-textanalytics/${SDK_VERSION}`;
        if (!pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions = {};
        }
        if (pipelineOptions.userAgentOptions.userAgentPrefix) {
            pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                additionalAllowedHeaderNames: ["x-ms-correlation-request-id", "x-ms-request-id"]
            }
        });
        this.client = new GeneratedClient(this.endpointUrl, internalPipelineOptions);
        const authPolicy = coreAuth.isTokenCredential(credential)
            ? coreRestPipeline.bearerTokenAuthenticationPolicy({ credential, scopes: DEFAULT_COGNITIVE_SCOPE })
            : textAnalyticsAzureKeyCredentialPolicy(credential);
        this.client.pipeline.addPolicy(authPolicy);
    }
    async detectLanguage(documents, countryHintOrOptions, options) {
        let realOptions;
        let realInputs;
        if (!Array.isArray(documents) || documents.length === 0) {
            throw new Error("'documents' must be a non-empty array");
        }
        if (isStringArray(documents)) {
            const countryHint = countryHintOrOptions || this.defaultCountryHint;
            realInputs = convertToDetectLanguageInput(documents, countryHint);
            realOptions = options || {};
        }
        else {
            // Replace "none" hints with ""
            realInputs = documents.map((input) => (Object.assign(Object.assign({}, input), { countryHint: input.countryHint === "none" ? "" : input.countryHint })));
            realOptions = countryHintOrOptions || {};
        }
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-detectLanguages", makeGeneratedDetectLanguageOptions(realOptions));
        try {
            const result = await this.client.languages({
                documents: realInputs
            }, finalOptions);
            return makeDetectLanguageResultArray(realInputs, result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async recognizeEntities(documents, languageOrOptions, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        let realOptions;
        let realInputs;
        if (!Array.isArray(documents) || documents.length === 0) {
            throw new Error("'documents' must be a non-empty array");
        }
        if (isStringArray(documents)) {
            const language = languageOrOptions || this.defaultLanguage;
            realInputs = convertToTextDocumentInput(documents, language);
            realOptions = options || {};
        }
        else {
            realInputs = documents;
            realOptions = languageOrOptions || {};
        }
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeEntities", makeGeneratedRecognizeCategorizedEntitiesOptions(realOptions));
        try {
            const result = await this.client.entitiesRecognitionGeneral({
                documents: realInputs
            }, finalOptions);
            return makeRecognizeCategorizedEntitiesResultArray(realInputs, result);
        }
        catch (e) {
            /**
             * This special logic handles REST exception with code
             * InvalidDocumentBatch and is needed to maintain backward compatability
             * with sdk v5.0.0 and earlier. In general, REST exceptions are thrown as
             * is and include both outer and inner exception codes. However, the
             * earlier versions were throwing an exception that included the inner
             * code only.
             */
            const backwardCompatibleException = handleInvalidDocumentBatch(e);
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: backwardCompatibleException.message
            });
            throw backwardCompatibleException;
        }
        finally {
            span.end();
        }
    }
    async analyzeSentiment(documents, languageOrOptions, options) {
        let realOptions;
        let realInputs;
        if (!Array.isArray(documents) || documents.length === 0) {
            throw new Error("'documents' must be a non-empty array");
        }
        if (isStringArray(documents)) {
            const language = languageOrOptions || this.defaultLanguage;
            realInputs = convertToTextDocumentInput(documents, language);
            realOptions = options || {};
        }
        else {
            realInputs = documents;
            realOptions = languageOrOptions || {};
        }
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-analyzeSentiment", makeGeneratedAnalyzeSentimentOptions(realOptions));
        try {
            const result = await this.client.sentiment({
                documents: realInputs
            }, finalOptions);
            return makeAnalyzeSentimentResultArray(realInputs, result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async extractKeyPhrases(documents, languageOrOptions, options) {
        let realOptions;
        let realInputs;
        if (!Array.isArray(documents) || documents.length === 0) {
            throw new Error("'documents' must be a non-empty array");
        }
        if (isStringArray(documents)) {
            const language = languageOrOptions || this.defaultLanguage;
            realInputs = convertToTextDocumentInput(documents, language);
            realOptions = options || {};
        }
        else {
            realInputs = documents;
            realOptions = languageOrOptions || {};
        }
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-extractKeyPhrases", makeGeneratedExtractKeyPhrasesOptions(realOptions));
        try {
            const result = await this.client.keyPhrases({
                documents: realInputs
            }, finalOptions);
            return makeExtractKeyPhrasesResultArray(realInputs, result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async recognizePiiEntities(inputs, languageOrOptions, options) {
        let realOptions;
        let realInputs;
        if (isStringArray(inputs)) {
            const language = languageOrOptions || this.defaultLanguage;
            realInputs = convertToTextDocumentInput(inputs, language);
            realOptions = options || {};
        }
        else {
            realInputs = inputs;
            realOptions = languageOrOptions || {};
        }
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizePiiEntities", makeGeneratedRecognizePiiEntitiesOptions(realOptions));
        try {
            const result = await this.client.entitiesRecognitionPii({
                documents: realInputs
            }, finalOptions);
            return makeRecognizePiiEntitiesResultArray(realInputs, result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async recognizeLinkedEntities(documents, languageOrOptions, options) {
        let realOptions;
        let realInputs;
        if (!Array.isArray(documents) || documents.length === 0) {
            throw new Error("'documents' must be a non-empty array");
        }
        if (isStringArray(documents)) {
            const language = languageOrOptions || this.defaultLanguage;
            realInputs = convertToTextDocumentInput(documents, language);
            realOptions = options || {};
        }
        else {
            realInputs = documents;
            realOptions = languageOrOptions || {};
        }
        const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeLinkedEntities", makeGeneratedRecognizeLinkingEntitiesOptions(realOptions));
        try {
            const result = await this.client.entitiesLinking({
                documents: realInputs
            }, finalOptions);
            return makeRecognizeLinkedEntitiesResultArray(realInputs, result);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async beginAnalyzeHealthcareEntities(documents, languageOrOptions, options) {
        let realOptions;
        let realInputs;
        if (isStringArray(documents)) {
            const language = languageOrOptions || this.defaultLanguage;
            realInputs = convertToTextDocumentInput(documents, language);
            realOptions = options || {};
        }
        else {
            realInputs = documents;
            realOptions = languageOrOptions || {};
        }
        const { updateIntervalInMs, resumeFrom } = realOptions, restOptions = tslib.__rest(realOptions, ["updateIntervalInMs", "resumeFrom"]);
        const poller = new BeginAnalyzeHealthcarePoller({
            client: this.client,
            documents: realInputs,
            options: restOptions,
            updateIntervalInMs: updateIntervalInMs,
            resumeFrom: resumeFrom
        });
        await poller.poll();
        return poller;
    }
    async beginAnalyzeActions(documents, actions, languageOrOptions, options) {
        let realOptions;
        let realInputs;
        if (!Array.isArray(documents) || documents.length === 0) {
            throw new Error("'documents' must be a non-empty array");
        }
        if (isStringArray(documents)) {
            const language = languageOrOptions || this.defaultLanguage;
            realInputs = convertToTextDocumentInput(documents, language);
            realOptions = options || {};
        }
        else {
            realInputs = documents;
            realOptions = languageOrOptions || {};
        }
        validateActions(actions);
        const compiledActions = compileAnalyzeInput(actions);
        const { updateIntervalInMs, resumeFrom } = realOptions, restOptions = tslib.__rest(realOptions, ["updateIntervalInMs", "resumeFrom"]);
        const poller = new BeginAnalyzeActionsPoller({
            client: this.client,
            documents: realInputs,
            actions: compiledActions,
            options: restOptions,
            resumeFrom: resumeFrom,
            updateIntervalInMs: updateIntervalInMs
        });
        await poller.poll();
        return poller;
    }
}
function validateActions(actions) {
    function validateActionType(actionList, actionType) {
        var _a;
        if (((_a = actionList === null || actionList === void 0 ? void 0 : actionList.length) !== null && _a !== void 0 ? _a : 0) > 1) {
            throw new Error(`beginAnalyzeActions: Currently, the service can accept up to one action only for ${actionType} actions.`);
        }
    }
    validateActionType(actions.analyzeSentimentActions, `analyzeSentiment`);
    validateActionType(actions.extractKeyPhrasesActions, `extractKeyPhrases`);
    validateActionType(actions.recognizeEntitiesActions, `recognizeEntities`);
    validateActionType(actions.recognizeLinkedEntitiesActions, `recognizeLinkedEntities`);
    validateActionType(actions.recognizePiiEntitiesActions, `recognizePiiEntities`);
}
/**
 * @internal
 */
function compileAnalyzeInput(actions) {
    var _a, _b, _c, _d, _e;
    return {
        entityRecognitionPiiTasks: (_a = actions.recognizePiiEntitiesActions) === null || _a === void 0 ? void 0 : _a.map(compose(setStrEncodingParam, compose(setCategoriesFilter, addParamsToTask))),
        entityRecognitionTasks: (_b = actions.recognizeEntitiesActions) === null || _b === void 0 ? void 0 : _b.map(compose(setStrEncodingParam, addParamsToTask)),
        keyPhraseExtractionTasks: (_c = actions.extractKeyPhrasesActions) === null || _c === void 0 ? void 0 : _c.map(addParamsToTask),
        entityLinkingTasks: (_d = actions.recognizeLinkedEntitiesActions) === null || _d === void 0 ? void 0 : _d.map(compose(setStrEncodingParam, addParamsToTask)),
        sentimentAnalysisTasks: (_e = actions.analyzeSentimentActions) === null || _e === void 0 ? void 0 : _e.map(compose(setStrEncodingParam, compose(setOpinionMining, addParamsToTask)))
    };
}
function isStringArray(documents) {
    return typeof documents[0] === "string";
}
/**
 * @internal
 */
function convertToDetectLanguageInput(inputs, countryHint) {
    if (countryHint === "none") {
        countryHint = "";
    }
    return inputs.map((text, index) => {
        return {
            id: String(index),
            countryHint,
            text
        };
    });
}
/**
 * @internal
 */
function convertToTextDocumentInput(inputs, language) {
    return inputs.map((text, index) => {
        return {
            id: String(index),
            language,
            text
        };
    });
}
/**
 * Creates the options the service expects for the analyze sentiment API from the user friendly ones.
 * @param params - the user friendly parameters
 * @internal
 */
function makeGeneratedAnalyzeSentimentOptions(params) {
    return {
        abortSignal: params.abortSignal,
        opinionMining: params.includeOpinionMining,
        includeStatistics: params.includeStatistics,
        modelVersion: params.modelVersion,
        requestOptions: params.requestOptions,
        stringIndexType: setStrEncodingParamValue(params.stringIndexType),
        tracingOptions: params.tracingOptions,
        onResponse: params.onResponse,
        serializerOptions: params.serializerOptions,
        loggingOptOut: params.disableServiceLogs
    };
}
/**
 * Creates the options the service expects for the recognize pii entities API from the user friendly ones.
 * @param params - the user friendly parameters
 * @internal
 */
function makeGeneratedRecognizePiiEntitiesOptions(params) {
    return {
        abortSignal: params.abortSignal,
        domain: params.domainFilter,
        includeStatistics: params.includeStatistics,
        modelVersion: params.modelVersion,
        requestOptions: params.requestOptions,
        stringIndexType: setStrEncodingParamValue(params.stringIndexType),
        tracingOptions: params.tracingOptions,
        piiCategories: params.categoriesFilter,
        onResponse: params.onResponse,
        serializerOptions: params.serializerOptions,
        loggingOptOut: params.disableServiceLogs
    };
}
/**
 * Creates the options the service expects for the recognize entities API from the user friendly ones.
 * @param params - the user friendly parameters
 * @internal
 */
function makeGeneratedRecognizeCategorizedEntitiesOptions(params) {
    return {
        abortSignal: params.abortSignal,
        includeStatistics: params.includeStatistics,
        modelVersion: params.modelVersion,
        requestOptions: params.requestOptions,
        stringIndexType: setStrEncodingParamValue(params.stringIndexType),
        tracingOptions: params.tracingOptions,
        onResponse: params.onResponse,
        serializerOptions: params.serializerOptions,
        loggingOptOut: params.disableServiceLogs
    };
}
/**
 * Creates the options the service expects for the detect language API from the user friendly ones.
 * @param params - the user friendly parameters
 * @internal
 */
function makeGeneratedDetectLanguageOptions(params) {
    return {
        abortSignal: params.abortSignal,
        includeStatistics: params.includeStatistics,
        modelVersion: params.modelVersion,
        requestOptions: params.requestOptions,
        tracingOptions: params.tracingOptions,
        onResponse: params.onResponse,
        serializerOptions: params.serializerOptions,
        loggingOptOut: params.disableServiceLogs
    };
}
/**
 * Creates the options the service expects for the extract key phrases API from the user friendly ones.
 * @param params - the user friendly parameters
 * @internal
 */
function makeGeneratedExtractKeyPhrasesOptions(params) {
    return {
        abortSignal: params.abortSignal,
        includeStatistics: params.includeStatistics,
        modelVersion: params.modelVersion,
        requestOptions: params.requestOptions,
        tracingOptions: params.tracingOptions,
        onResponse: params.onResponse,
        serializerOptions: params.serializerOptions,
        loggingOptOut: params.disableServiceLogs
    };
}
/**
 * Creates the options the service expects for the recognize linked entities API from the user friendly ones.
 * @param params - the user friendly parameters
 * @internal
 */
function makeGeneratedRecognizeLinkingEntitiesOptions(params) {
    return {
        abortSignal: params.abortSignal,
        includeStatistics: params.includeStatistics,
        modelVersion: params.modelVersion,
        requestOptions: params.requestOptions,
        tracingOptions: params.tracingOptions,
        onResponse: params.onResponse,
        serializerOptions: params.serializerOptions,
        loggingOptOut: params.disableServiceLogs,
        stringIndexType: setStrEncodingParamValue(params.stringIndexType)
    };
}

Object.defineProperty(exports, 'AzureKeyCredential', {
    enumerable: true,
    get: function () {
        return coreAuth.AzureKeyCredential;
    }
});
exports.TextAnalyticsClient = TextAnalyticsClient;
//# sourceMappingURL=index.js.map
